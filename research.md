---
layout: page
title: Research
permalink: /research/
---

These are the research areas that I work on currently.
For my past research work click <a href="/pastresearch/">here</a>.

<h1>Mining Software Repositories</h1>
<p>Nowadays, software development has been greatly influenced by the vastness of available online resources, including source code indexes (e.g. GitHub), question-answering communities (e.g. Stack Overflow), source code search engines, etc. A new problem-solving paradigm has emerged; developers search online for solutions to their problems and integrate them, thus greatly reducing development time and most of the time even improving the overall quality of the software product. Interesting lines of work in this area involve analyzing the problem of locating useful solutions and/or reusable software components from a functionality and from a reusability perspective.</p>

<img class="alignleft" src="/images/stackoverflow.png" style="width: 215px;"/>

<p>A typical example of locating useful information is that of searching in a question-answering community. In this context, the challenge for developers usually lies in effectively navigating between question posts until they find a similar question that has already been answered. A proposed improvement on current question-answering systems involves using the main elements of a question post, including not only its title, tags, and body, but also its source code snippets. This is the subject of our latest work, which involves designing <a target="_blank" href="http://ieeexplore.ieee.org/document/7180116/">a similarity scheme for the title, tags, body, and source code snippets of question posts in Stack Overflow</a> and illustrating how the extracted information can be used to further improve the retrieval of questions. Using this methodology, similar question posts can be recommended more effectively while community members can search for solutions even without fully forming a question.</p>

<img class="alignright" src="/images/rsse.png" style="width: 435px;"/>

<p>In accordance with the typical scenario of finding reusable software components and integrating them to one's source code as outline above, several systems have already been developed. These systems lie in the area of Recommendation Systems in Software Engineering (RSSEs). Most RSSEs focus on covering the functionality desired by the developer, while possibly neglecting the quality of the recommended code. As an improvement we have proposed <a target="_blank" href="http://dl.acm.org/citation.cfm?id=2903492">an RSSE that employs functional and non-functional component selection criteria</a> in order to provide not only a functional ranking for the retrieved components, but also a reusability score for each component based on configurable thresholds of source code metrics.</p>

<h1>Software Quality</h1>
<p>Software Quality is a rather broad concept, as it means different things to different people. In the context of software development, source code analysis may be distinguished into static analysis and dynamic analysis. Static analysis involves analyzing the source code of a software project or generally component, whereas dynamic analysis operates on the executable (bytecode) of the component, usually by analyzing execution traces. Certain lines of work in this area focus on improving existing software quality and on localizing or predicting bugs in a software system, either by using the aforementioned source code metrics or by using metrics from version control systems.</p>

<img class="alignleft" src="/images/qualityestimation.png" style="width: 335px;"/>

<p>Concerning static analysis, there are several tools that aspire to assess the quality of source code using source code metrics such as e.g. Number of Lines of Code, McCabe Computational Complexity etc. These tools usually include a model with thresholds for these metrics which has to be defined by some experts. Our work in this area (performed with Michail Papamichail and Andreas Symeonidis) involves constructing <a target="_blank" href="http://ieeexplore.ieee.org/document/7589790/">a generic methodology that relates quality with source code metrics</a> while alleviating the need for expert help by using software component popularity as ground truth. Using the methodology, developers are able to evaluate the quality of components found in online sources before integrating them in their source code. The system initially rules out any low quality code using a one-class classifier, and subsequently computes a quality score for each software component by means of a neural network trained on high quality code.</p>

<img class="alignright" src="/images/subgraphmining.png" style="width: 315px;"/>

<p>Another quite interesting research area of software quality is that of dynamic bug localization. The main concept of this area involves determining the location of non-crashing software bugs using dynamic analysis, i.e. parsing function call traces. An example methodology involves instrumenting the source code of an application, collecting function call traces and representing them as graphs. After that, these graphs are mined using subgraph mining algorithms in order to detect interesting patterns, i.e. patterns occuring mostly on erroneous executions, and thus provide a ranking of potentially buggy functions-nodes. An interesting extension to existing work is <a target="_blank" href="https://www.thinkmind.org/index.php?view=article&articleid=icsea_2013_2_30_10250">the application of tree edit distance algorithms</a> in order to reduce the graph dataset and improve the scalability and effectiveness of state-of-the-art methods. Further exploring the task of selecting the most significant patterns, we also propose <a target="_blank" href="https://www.thinkmind.org/index.php?view=article&articleid=soft_v7_n12_2014_22">a set of different call trace selection techniques</a> based on the Stable Marriage problem to localize possibly buggy areas more effectively.</p>

<img class="alignleft" src="/images/reliabilityanalysis.png" style="width: 310px;"/>

<p>Focusing on metrics derived from version control systems, the problem, which can also be defined as Software Reliability Prediction, has attracted the attention of several researchers and thus several classification techniques have been developed in order to classify software components as defect-prone or defect-free. Further advancing current research, our work in this area involves designing <a target="_blank" href="http://ieeexplore.ieee.org/document/7168329/">a genetic fuzzy rule-based system</a> so as to produce interpretable output concerning software reliability. In specific, the system uses a Mamdani-Assilian inference engine and the problem is modeled as a one-class classification task (where the class that is predicted is the defect-proneness of software classes). The genetic algorithm follows the Pittsburgh approach where each chromosome represents a rule base.</p>

<img class="alignright" src="/images/designpattern.png" style="width: 415px;"/>

<p>Apart from quality measured by source code metrics and bug detection, an interesting line of research involves determining whether a software project follows certain design patterns. Design patters are typically employed to cover the non-functional aspects of the system and thus identifying them is important for understanding and subsequently reusing or maintaining a software project. This is a task performed by Design Pattern Detection (DPD) tools, which may operate on the source code or on some other representation of the information. Our work in this area (performed with Antonis Noutsos and Andreas Symeonidis) resulted in <a target="_blank" href="https://github.com/AuthEceSoftEng/DP-CORE">a design pattern detection tool with a descriptive representation</a> that recovers design patterns from source code. Compared to other DPD tools that identify known patterns, our tool also detects custom patterns while it also allows identifying exact and approximate pattern variations even in non-compilable code.</p>

<h1>Software Requirements</h1>

<p>The translation of requirements to specifications and subsequently source code is one of the most challenging tasks of the software development process. In specific, requirements are usually provided in multimodal formats, including e.g. natural language text, graphical storyboards, etc., hence mapping them to specifications requires designing the appropriate representations. Furthermore, since functional requirements are commonly written in natural language, they are prone to ambiguity, incompleteness and inconsistency.</p>

<img class="alignleft" src="/images/functionalrequirements.png" style="width: 425px;"/>

<p>As a result, there are several approaches that constrain the input format of requirements, use controlled languages and/or require considerable human effort in order to translate them to specifications. An interesting idea is the automation of the process of converting natural language input to formal semantic representations using semantic parsers. Our latest work in this area involved formally defining the problem, designing <a target="_blank" href="https://www.semanticscholar.org/paper/1053d05a169806d730ca5459c8aa65f2b9318ce3">an hierarchical annotation framework and a requirements ontology</a> to allow intuitively marking and storing requirements concepts. After that, <a target="_blank" href="https://link.springer.com/article/10.1007/s10579-017-9381-z">requirements concepts are identified using semantic role labeling techniques</a> and finally these concepts are stored in the ontology to allow further processing.</p>

<img class="alignright" src="/images/graphicalstoryboard.png" style="width: 425px;"/>

<p>Another issue when converting requirements to specifications is the integration of requirements from different sources having also possibly different formats. These specifications can then later be used to provide the model of the application or even generate its source code using Model-Driven Engineering (MDE). In this context, we have developed <a target="_blank" href="https://link.springer.com/article/10.1007/s10515-016-0206-x">a methodology that allows developers to design their envisioned system through software requirements in multimodal formats</a>. Our methodology employs natural language processing techniques and semantics in order to process textual requirements and graphical storyboards and integrate them into specifications. The procedure is also traceable, as any changes in software requirements are propagated to the produces software models.</p>

